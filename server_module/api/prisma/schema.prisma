generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ClientGender {
  MALE
  FEMALE
}

enum BookingStatus {
  ACTIVE
  CANCELED
  COMPLETED
  PENDING_PAYMENT
}

enum PaymentKind {
  DEPOSIT
  REMAINING
  EXTRA
  REFUND
}

enum UserRole {
  ADMIN
  OWNER
  WASHER
}

enum ShiftStatus {
  OPEN
  CLOSED
}

enum AuditType {
  BOOKING_MOVE
  BOOKING_DELETE
  BOOKING_CHANGE_SERVICE
  BOOKING_CHANGE_BODYTYPE
  BOOKING_DISCOUNT
  BOOKING_START
  BOOKING_FINISH

  BAY_CLOSE
  BAY_OPEN

  SHIFT_OPEN
  SHIFT_CLOSE

  CLIENT_BLOCK
  CLIENT_UNBLOCK
}

model Location {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name     String @unique
  address  String?
  colorHex String @default("#2D9CDB")

  /// для UI/дефолтов (можно оставить, но Bays — источник правды)
  baysCount Int @default(2)

  bays     Bay[]
  bookings Booking[]
  users    User[]
  shifts   Shift[]

  /// membership клиентов в этой локации
  clientLinks ClientLocation[]

  @@index([createdAt])
}

model Bay {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  locationId String
  location   Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  /// номер поста внутри локации (1..N)
  number Int

  /// мгновенно отключить пост (авария/ремонт)
  isActive Boolean @default(true)

  /// почему отключили (если отключили)
  closedReason String?
  closedAt     DateTime?
  reopenedAt   DateTime?

  @@unique([locationId, number])
  @@index([locationId])
  @@index([locationId, isActive])
}

model Client {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  phone String @unique
  name  String?

  /// для walk-in по телефону делаем optional
  gender    ClientGender?
  birthDate DateTime?

  /// LEGACY: глобальная блокировка (оставлено, чтобы не ломать старый код)
  /// НОВАЯ логика блокировки должна жить в ClientLocation (по локации).
  isBlocked       Boolean  @default(false)
  blockReason     String?
  blockedAt       DateTime?
  blockedByUserId String?

  cars     Car[]
  bookings Booking[]

  /// membership по локациям
  locations ClientLocation[]

  @@index([phone])
  @@index([createdAt])
  @@index([isBlocked])
}

model ClientLocation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId   String
  locationId String

  /// блокировка клиента именно в этой локации
  isBlocked       Boolean  @default(false)
  blockReason     String?
  blockedAt       DateTime?
  blockedByUserId String?

  /// полезно для аналитики
  lastVisitAt DateTime?

  client   Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  @@unique([clientId, locationId])
  @@index([locationId])
  @@index([clientId])
  @@index([locationId, isBlocked])
}

model Car {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  makeDisplay  String
  modelDisplay String
  plateDisplay String

  makeNormalized  String
  modelNormalized String
  plateNormalized String @unique

  year     Int?
  color    String?
  bodyType String?

  // ✅ связь с Client (пока nullable для демо)
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  bookings Booking[]

  @@index([clientId])
}

model Service {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String @unique
  priceRub    Int
  durationMin Int    @default(30)

  bookings Booking[]
}

model Booking {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Локация (мойка)
  locationId String
  location   Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  /// Привязка к смене (для строгого scope админа)
  shiftId String?
  shift   Shift? @relation(fields: [shiftId], references: [id], onDelete: SetNull)

  /// Время начала услуги (план)
  dateTime DateTime

  /// Номер поста (1, 2, …) внутри локации
  bayId Int @default(1)

  /// Буфер в минутах (обычно 15)
  bufferMin Int @default(0)

  /// Сумма брони (например 500 ₽)
  depositRub Int @default(0)

  /// Комментарий клиента
  comment String?

  /// Комментарий админа (видит admin/owner)
  adminNote String?

  /// Факт начала/окончания работ
  startedAt  DateTime?
  finishedAt DateTime?

  /// Статус записи
  status BookingStatus @default(PENDING_PAYMENT)

  /// Дедлайн оплаты депозита (удобно только для PENDING_PAYMENT)
  paymentDueAt DateTime?

  /// Отмена
  canceledAt   DateTime?
  cancelReason String?

  carId     String
  serviceId String

  /// прямая ссылка на клиента (nullable для демо)
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id], onDelete: SetNull)

  car     Car     @relation(fields: [carId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  payments Payment[]

  @@index([locationId])
  @@index([locationId, bayId])
  @@index([locationId, dateTime])
  @@index([shiftId])
  @@index([carId])
  @@index([serviceId])
  @@index([clientId])
  @@index([dateTime])
  @@index([status])
  @@index([paymentDueAt])
  @@index([bayId])
}

model Payment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  paidAt    DateTime @default(now())

  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  amountRub Int
  method    String
  kind      PaymentKind

  @@index([bookingId])
  @@index([paidAt])
  @@index([kind])

  /// 1 депозит + 1 доплата (если захочешь больше — уберём это ограничение)
  @@unique([bookingId, kind])
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  phone    String @unique
  name     String?
  role     UserRole
  isActive Boolean @default(true)

  // scope
  locationId String
  location   Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  // для admin-логики (быстро понять есть ли открытая смена)
  shiftOpenAt  DateTime?
  shiftCloseAt DateTime?

  shifts Shift[]
  audits AuditEvent[]

  @@index([role])
  @@index([locationId])
  @@index([isActive])
}

model Shift {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  locationId String
  adminId    String

  status   ShiftStatus @default(OPEN)
  openedAt DateTime    @default(now())
  closedAt DateTime?

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  admin    User     @relation(fields: [adminId], references: [id], onDelete: Cascade)

  bookings Booking[]

  @@index([locationId, openedAt])
  @@index([adminId, openedAt])
  @@index([status])
}

model AuditEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  type AuditType

  locationId String?
  userId     String?
  shiftId    String?
  bookingId  String?
  clientId   String?

  /// обязательное поле для “опасных” операций
  reason  String?
  payload Json?

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([type])
  @@index([createdAt])
  @@index([locationId])
  @@index([userId])
  @@index([shiftId])
  @@index([bookingId])
  @@index([clientId])
}
